# 准备工作

在`server.dbctrl.manager.CDBManager.__init__`中修改mysql的密码，为自己笔记本上的密码（为空）

使用anaconda管理环境，创建环境

```powershell
conda create -n game python=3.7

# 进入环境
conda activate game

# 进入目录
cd C:\Users\Administrator\Desktop\note\游戏程序训练营-校内任务\游戏程序训练营-校内任务\服务器课程材料\服务端课程\教程\task\6_战斗
```

注意：游戏使用右键移动

## 地图

练习：添加宝箱

## 战斗

添加三连击

`server.war.defines增加三连击常量`

```python
MSG_TRIPLEATTACK = 3 #a战士发动技能 三连击(进攻者名字， 进攻者位置)
```



`server.war.perform`中添加

```python
class CTripleAttack(CPerform):
# 三连击	
	def Perform(self):
		oWar = self.m_Warrior.m_War
		oReport = oWar.m_Report
		oReport.AddMsg(MSG_TRIPLEATTACK, self.m_Warrior.Name())

		for _ in range(3):
			lstEnemy = self.m_Warrior.GetEnemy()
			lstEnemy = [oEnemy for oEnemy in lstEnemy if oEnemy.IsAlive()]
			if not lstEnemy:
				return
			oTarget = RandomList(lstEnemy)
			iDamage = self.m_Warrior.m_Att - oTarget.m_Def
			iReadDamage = min(oTarget.m_HP, iDamage)
			oTarget.m_HP = oTarget.m_HP-iReadDamage
		
			oWar = self.m_Warrior.m_War
			oReport = oWar.m_Report
			oReport.AddMsg(MSG_ATTACK, self.m_Warrior.Name(), self.m_Warrior.m_Pos, oTarget.Name(), oTarget.m_Pos, iReadDamage)
```



`server.war.warrior.CWarrior.Config`中添加

```python
oTripleAttack = CTripleAttack(self)
self.m_Perform.append(oTripleAttack)
```



`client.report`中增加三连击文本

```python
TEXT = {
	1: "第{0}回合:",
	2: "{0}战士攻击{2}战士,造成伤害{4}",
	3: "{0}战士发动技能 三连击"
}
```

## 大作业

### 1. 生成大盗

`server.mapobj.mapunit`中添加蒙面大盗类，其中实现自动移动

```python
class CThiefUnit(CMapUnit):
	def __init__(self, oMap, iUnitIdx):
		super().__init__(oMap, iUnitIdx)
		self.m_TimeWait = 1
		# 初始化最后移动时间
		import time
		self.m_LastMoveTime = time.time()
		# 初始化时设置第一个定时器
		oCB = Functor(self.autoMove)
		timecontrol.Call_Out(oCB, self.m_TimeWait, "Move%s" % self.m_UnitIdx)
			

	m_Type = UNIT_THIEF
	
	def Config(self, iThief, tPos):
		self.m_Owner = iThief
		self.m_Pos = tPos
		
	def Name(self):
		return "蒙面大盗%s" % self.m_Owner
		
	def GetPackInfo(self):
		return [self.m_UnitIdx, self.m_Type, self.m_Pos, self.m_Owner, self.m_Moving, 
			self.m_StepStart, self.m_MovePathIdx, self.m_MovePath]	

	def autoMove(self):
		# 随机移动方向
		directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
		direction = random.choice(directions)
		tMovePos = (self.m_Pos[0]+direction[0], self.m_Pos[1]+direction[1])
		
		# 检查目标位置是否在地图范围内
		is_in_map = False
		try:
			is_in_map = (0 <= tMovePos[0] < len(self.m_Map.m_Block[0])) and (0 <= tMovePos[1] < len(self.m_Map.m_Block))
		except:
			print(f"大盗{self.m_UnitIdx}，地图范围检查出错")
		
		is_block = not is_in_map
		if is_in_map:
			is_block = self.m_Map.IsBlock(tMovePos)
		
		print(f"大盗{self.m_UnitIdx}，当前位置：{self.m_Pos}，移动状态：{self.m_Moving}，尝试移动到：{tMovePos}，是否在地图内：{is_in_map}，是否为阻挡：{is_block}")
		
		# 如果移动状态长时间为1，强制重置（防止状态卡住）
		if self.m_Moving and hasattr(self, 'm_LastMoveTime'):
			import time
			current_time = time.time()
			if current_time - self.m_LastMoveTime > 5:  # 5秒没完成移动，强制重置
				print(f"大盗{self.m_UnitIdx}，移动状态卡住，强制重置")
				self.ClearMove()
		
		# 只有当不在移动中且目标位置有效且不是阻挡时才执行移动
		if not self.m_Moving and is_in_map and not is_block:
			# 直接使用简单的移动，跳过A*寻路，因为我们只移动一格
			self.m_Moving = 1
			self.m_MovePath = [self.m_Pos, tMovePos]
			self.m_MovePathIdx = 0
			self.m_StepStart = TupleTime()
			# 记录最后移动时间
			import time
			self.m_LastMoveTime = time.time()
			oCB = Functor(UnitMoveStep, self.m_UnitIdx)
			timecontrol.Call_Out(oCB, self.m_MoveTime, "Move%s" % self.m_UnitIdx)
			self.Refresh()
			print(f"大盗{self.m_UnitIdx}，开始移动，路径：{self.m_MovePath}")
			# 移动时间设置为移动一格所需时间+0.3秒，确保移动完成后再设置下一次定时器
			wait_time = self.m_MoveTime + 0.3
		else:
			# 如果是阻挡位置、超出地图范围或正在移动，稍后尝试下一次移动
			wait_time = 0.5
		
		# 设置下一次定时器
		oCB = Functor(self.autoMove)
		timecontrol.Call_Out(oCB, wait_time, "Move%s" % self.m_UnitIdx)
```

`server.mapobj.mapobject`中添加生成蒙面大盗的方法，随机选择一个没有阻塞的位置生成。以及在用户进入时调用方法开始生成蒙面大盗，定时每10秒回调一次，直到生成10个。

```python
def NewThiefUnit(self, iThief):
		iUnitIdx = self.NewUnitIdx()
		oUnit = mapunit.CThiefUnit(self, iUnitIdx)
		self.m_MapUnit[iUnitIdx] = oUnit
		return oUnit
		
def ThiefEnter(self):

    # 检查是否已达到最大小偷数量
    if self.m_ThiefCount < self.m_MaxThiefCount:
        # 查找一个非阻挡位置生成小偷
        tPos = (random.randint(0, len(self.m_Block[0])-1), random.randint(0, len(self.m_Block)-1))
        while self.IsBlock(tPos):
            tPos = (random.randint(0, len(self.m_Block[0])-1), random.randint(0, len(self.m_Block)-1))

        # 创建小偷单位
        iThief = self.NewUnitIdx()  # 小偷ID生成
        oThiefUnit = self.NewThiefUnit(iThief)
        oThiefUnit.Config(iThief, tPos)  # 设置小偷位置
        oThiefUnit.Refresh()  # 刷新到所有客户端
        self.m_ThiefCount += 1
        print(f"创建小偷单位，小偷数量：{self.m_ThiefCount}, 小偷位置:{oThiefUnit.m_Pos}")

        for oUnit in self.m_MapUnit.values():
            oUnit.Refresh()
    else:
        print(f"已达到最大小偷数量：{self.m_MaxThiefCount}")

    timecontrol.Call_Out(Functor(self.ThiefEnter), 10, f"GenerateThief{self.m_ThiefCount}")

```

### 2. 大盗的战斗逻辑

`server.war`中添加大盗的战斗单位`thief.py`

`server.war.perform`中添加技能暴雨梨花针和飞檐走壁

修改客户端以及服务端的检测机制`client.core.CharWalk.CheckFight`以及`server.mapobj.mapobject.Enterfight`，使玩家可以和大盗触发战斗

### 3. 战士的耐力机制
